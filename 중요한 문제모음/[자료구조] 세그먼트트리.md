# ✅ 세그먼트 트리 

## 💡 세그트리 개념

- **구간 합, 최솟값, 최댓값 등 구간 쿼리를 O(log N) 시간에 처리하기 위한 트리 구조**
- **완전 이진 트리 형태**  
  N개의 원소를 담으려면 리프 노드 개수가 N 이상인 2의 거듭제곱이어야 함  
  → 리프 노드 수: `2^ceil(log2 N)`

- 트리 전체 노드 수는 최대 `2 * 2^ceil(log₂N) - 1`
- 배열 크기는 안전하게 `4 * N` 정도를 잡으면 된다 (보통 4N을 넘지 않음)

---
### ⏱️ 일반 배열 / 누적합 / 세그트리 시간 복잡도 비교

| 자료구조         | 업데이트 시간복잡도           | 구간 질의 시간복잡도 |
|------------------|------------------------------|----------------------|
| 일반 배열         |**O(1)**                          | O(N)                 |
| 누적합 배열       | O(N)                      | **O(1)**                 |
| 세그먼트 트리     | **O(log₂N)**                      | **O(log₂N)**             |


---

## 💡 오늘 고민한 주요 내용

- **세그먼트 트리를 왜 쓰는지?**

- 일반 배열, 누적합 배열로는 **업데이트와 구간 질의를 모두 빠르게 처리할 수 없음**
- 세그먼트 트리는 **O(log₂N)** 시간에 구간 합, 최소/최대, 구간 gcd 등 다양한 구간 연산을 지원  
- 특히 **데이터가 변경되면서 구간 질의를 여러 번 수행해야 할 때 최적**
- ex) 동적 구간 합, 최솟값 갱신 + 질의 문제, 여러 번의 쿼리와 업데이트가 섞인 문제

- **왜 배열 크기를 4N으로 잡나?**  
  → 세그트리는 완전 이진 트리라서 위로 갈수록 절반씩 줄어들어 전체 노드 수는 4N을 넘지 않음  
  → `4N` > `2 * 2^ceil(log₂N) - 1` 으로 4N으로 크기를 잡아 여유있게 배열크기를 유지

- **리프 노드는 원본 데이터와 매핑됨**
- **구간이 클수록 부모 노드는 더 큰 범위를 담고 있음**
- **세그트리 업데이트 / 쿼리 시간 복잡도:** O(log₂N)
- **빌드 시간 복잡도:** O(N)

---

## 💡 세그먼트트리 배열 인덱스와 구조 이해

- 리프 노드가 N개 이상 되도록 **2의 거듭제곱**으로 맞춤  
- 리프 노드 + 내부 노드 포함 최대 `4N` 크기의 배열이면 충분  
- 배열의 각 인덱스는 구간 `[L, R]` 의 값을 관리  
- **구간을 나누는 방식 때문에 일부 배열 인덱스는 공간이 비는 것처럼 보일 수 있음**  
- 자식 노드는 **왼쪽: 2 * n, 오른쪽: 2 * n + 1** 인덱스를 가짐  
- 부모는 자식을 병합하여 값을 계산 (예: 합, 최솟값, 최댓값)


---

## 💡 앞으로 공부할 내용

- 직접 구현해보며 빌드 / 업데이트 / 쿼리 과정을 손에 익히기
- 느리게 갱신되는 세그먼트트리 (Lazy Propagation)도 다음에 도전

---

## ✨ 느낀 점

- 세그트리 구조가 처음엔 헷갈렸지만, 완전 이진 트리 개념과 함께 자료구조 지식이 있어 이해하는데 도움이 됐다!

