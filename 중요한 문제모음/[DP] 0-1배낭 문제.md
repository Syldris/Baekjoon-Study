## [백준 12865번: 평범한 배낭](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/12865.%E2%80%85%ED%8F%89%EB%B2%94%ED%95%9C%E2%80%85%EB%B0%B0%EB%82%AD)

```csharp
for (int j = k; j >= weight; j--)
{
    dp[j] = Math.Max(dp[j], dp[j - weight] + money);
}
```

### ✅ 문제 요약

**0-1 배낭 문제**는 결국 **"각 아이템을 넣느냐, 안 넣느냐"**  
이 두 가지 선택법을 고려하는 문제이다.

---

### 💡 핵심 개념

- `dp[j]`는 **무게 j일 때 가질 수 있는 최대 가치**

- `dp[j - weight] + money`는 **현재 물건을 넣었을 때의 가치**

| 경우 | 의미                            |
|------|---------------------------------|
| 1    | 안 넣는 경우 → `dp[j]`             |
| 2    | 넣는 경우 → `dp[j - weight] + money` |

두 경우 중 **더 높은 가치를 `Math.Max()`로 선택**한다.

---

### 🔁 역방향 순회 (`j--`)를 하는 이유

```csharp
for (int j = k; j >= weight; j--)
```

- 같은 물건을 **여러 번 쓰는 걸 방지**하기 위해서!
- 역방향으로 순회해야 **이전 단계의 값이 덮이지 않음**
- 즉, **각 물건은 1번만 사용되는 0-1 배낭 조건**을 만족시킨다.
