## [백준 11003번: 최솟값 찾기](https://www.acmicpc.net/problem/11003)

### ✅ 문제 요약

- 주어진 수열에서 **슬라이딩 윈도우의 크기** `L`에 대해, 각 위치마다 **윈도우 내 최솟값을 구하는 문제**
- 일반적으로 덱을 이용하여 O(N) 시간에 해결하는 방식이 사용되지만, 이번 풀이에서는 **우선순위 큐를 활용한 방법**을 구현했음

---

### 💡 핵심 개념

1. **슬라이딩 윈도우 + 자료구조 최적화**
   - 매 위치 `i`에서 `[i - L + 1, i]` 구간의 최솟값을 빠르게 구해야 함
   - 덱을 이용하는 대신, **우선순위 큐**를 통한 방식으로 해결

2. **우선순위 큐(PriorityQueue) + 인덱스 활용**
   - `PriorityQueue<(값, 인덱스), 값>` 형태로 선언하여 최소값이 항상 루트에 위치하도록 구성
   - 윈도우를 벗어난 인덱스는 루프를 통해 제거
   - 최소값의 인덱스가 i-l보다 같거나 작으면 제거하는 방식으로 슬라이딩 윈도우 구현

---

### ✅ C# 풀이 (우선순위 큐 활용)

```csharp
string[] inputs = sr.ReadLine().Split();
int n = int.Parse(inputs[0]);
int l = int.Parse(inputs[1]);
int[] arr = Array.ConvertAll(sr.ReadLine().Split(), int.Parse);
PriorityQueue<(int value, int index), int> pq = new();
StringBuilder sb = new StringBuilder();

for (int i = 0; i < n; i++)
{
    int num = arr[i];
    pq.Enqueue((num, i), num); // 값 기준 최소 우선순위 큐 삽입

    // 슬라이딩 윈도우 범위 밖의 값 제거
    while (pq.Peek().index <= i - l)
    {
        pq.Dequeue();
    }

    sb.Append(pq.Peek().value).Append(' ');
}

sw.Write(sb);

