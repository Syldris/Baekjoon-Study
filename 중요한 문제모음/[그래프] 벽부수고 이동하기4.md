## [백준 16946번: 벽 부수고 이동하기 4](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/16946.%E2%80%85%EB%B2%BD%E2%80%85%EB%B6%80%EC%88%98%EA%B3%A0%E2%80%85%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0%E2%80%854)

### ✅ 문제 요약
- `0`은 이동 가능한 칸, `1`은 벽.
- 벽(1)을 부쉈을 때 **이동 가능한 0 지역들의 합**을 구해 출력.
- 출력할 때는 `(합 + 1) % 10` 한 값을 출력해야 함.

---
### 🎯 간단한 흐름 요약

1. **0 지역**을 BFS로 그룹핑하면서  
   → 그룹 번호(tag)와 그룹 크기(result)를 기록해둔다.

2. **벽(1) 주변**을 탐색할 때  
   → 인접한 **서로 다른 그룹**만 골라서 크기를 합산한다.

3. **(합 + 1) % 10** 계산하여 출력한다 <=벽 위치포함!

---
### 💡 핵심 개념

| 개념 | 설명 |
|:---|:---|
| 0 지역 그룹핑 | BFS로 인접한 0들을 하나의 그룹으로 묶고, 그룹 크기를 저장한다. |
| 벽 주변 그룹 합산 | 벽(1) 기준으로 인접한 서로 다른 그룹 번호를 찾아 크기를 합산한다. |
| 중복 제거 | 같은 그룹을 여러 번 더하는 것을 방지하기 위해 `HashSet`을 사용한다. |
| 최종 결과 처리 | (합산한 0 지역 수 + 벽 본인 1개) % 10을 계산하여 출력한다. |

> 🎯 특히 **같은 그룹을 중복해서 더하지 않는 것**이 핵심 포인트!  
> 🎯 BFS를 통해 미리 0 지역의 크기와 그룹 번호를 계산해두는 것도 매우 중요!

---
### 자료구조 설명

| 자료구조   | 설명 |
|:---        |:---  |
| **`int[,] arr`** | 원본 맵 정보를 저장하는 배열. arr[x, y] 값이 0이면 이동 가능한 지역, 1이면 벽을 의미. |
| **`int[,] result`** | 0 지역의 크기를 저장하는 배열. 각 0 지역에 해당하는 크기 값이 저장된다. |
| **`int[,] tag`** | 각 0 지역에 대한 그룹 번호를 저장하는 배열. 그룹화된 각 0 지역은 고유한 번호로 구분된다. |
| **`bool[,] visited`** | 각 칸의 방문 여부를 기록하는 배열. BFS 탐색 시 이미 방문한 칸은 다시 방문하지 않도록 체크한다. |

---

## ⏳ 시간 복잡도 비교

### 1. **그룹화 방식 (최적화)**

- **BFS로 그룹화 후 벽 처리**:  
  - **그룹화** (BFS) = **O(N * M)**  
  - **벽 주변 그룹 합산** (최대 4개 그룹) = **O(1)** (중복 제거 후 합산)
  - **최종 출력** = **O(N * M)**

- 전체 시간 복잡도: **O(N * M)** (효율적!)
- 여기서 N = 1000, M = 1000 이므로, **N × M = 1,000,000** 수준이다.
### 2. **원래 방식 (비효율적)**

- **각 벽마다 주변 0 지역을 탐색**:  
  - **각 벽에 대해 4방향 탐색** 및 **각각의 0 지역 크기 계산**  
  - **최악의 경우**: 각 벽에 대해 **O(N * M)** 시간이 걸릴 수 있음.
  - 벽 개수는  **O(N * M)**  그러므로 최악의 경우 전체 시간 복잡도는 **O(N * M * (N * M))**
- 전체 시간 복잡도: **O(N * M * (N * M))** (비효율적!)
- 여기서 N = 1000, M = 1000 이므로, 최악의 경우 **N * M * (N * M) = 1,000,000,000,000** 수준이다.
---

## 📊 왜 **그룹화 방식**이 더 효율적일까?

- **그룹화 방식**에서는 벽(1)에 대해 **4방향만 확인**하고, 각 방향에 대해 그룹 번호를 **미리 계산**하여 그 크기만 합산함.  
  - 이로 인해 **중복된 그룹을 다시 계산**할 필요가 없고, 각 벽에 대해서 **O(1)** 시간만 들여 계산할 수 있음.
  
- 반면, **원래 방식**에서는 **각 벽마다 주변 0 지역을 탐색**하고, **그 크기를 계산**하는 데 더 많은 시간이 소요함.  
  - 특히 **최악의 경우**에는 벽 하나를 처리할 때마다 모든 0 지역을 다시 탐색하게 되므로 **O(N * M * (N * M))** 시간 복잡도가 발생함.

---

## ⏱ 결론

- **그룹화 방식**은 **O(N * M)** 시간 복잡도만 들고, **벽 부수기 방식**은 **O(N * M * (N * M))** 시간이 걸림!
- **그룹화**를 통해 **불필요한 계산을 방지**하고, **중복된 그룹을 제거**하면서 시간을 절약할 수 있기 때문에 훨씬 효율적인 방법!

---

### [📜 코드 요약](https://github.com/Syldris/Baekjoon-Study/blob/main/C%23/%EB%B0%B1%EC%A4%80/Gold/16946.%E2%80%85%EB%B2%BD%E2%80%85%EB%B6%80%EC%88%98%EA%B3%A0%E2%80%85%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0%E2%80%854/%EC%BD%94%EB%93%9C%EC%9A%94%EC%95%BD.md)
