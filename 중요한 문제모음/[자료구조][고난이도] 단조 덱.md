## ✅ 단조 덱 (Monotonic Deque)

### 💡 핵심 개념

덱(Deque) 내부 원소의 값이 단조롭게 정렬되도록 유지하면서,  
슬라이딩 윈도우 범위 안의 **최댓값(또는 최솟값)** 을 빠르게 구하는 자료구조이다.
- 단조덱은 항상 **내림차순(최댓값), 또는 오름차순(최솟값)** 형태로 유지한다.


> 📌 주로 **"슬라이딩 윈도우 안의 최대/최소"** 문제에서  
> **시간복잡도 `O(N)`** 으로 문제를 해결할 수 있는 테크닉 

---

### ⏱️ 시간복잡도
- **`N`** : **전체 배열**의 크기 (입력 배열 원소 개수)
- **`M`** : **슬라이딩 윈도우** 크기 (한 번에 보는 구간의 길이)

| 방식          | 시간복잡도   | 비고                      |
|---------------|--------------|--------------------------------|
| 완전탐색      | O(NM)        | 구간마다 `max()` 순회         |
| 우선순위 큐   | O(N log M)   | 시간 상수가 크게붙어 세그트리 보다 오래걸림         |
| **단조 덱**   | **O(N)**     | 최적, 인덱스당 최대 1번 삽입/삭제 |
| 세그트리      | O(N log M)   | 우선순위 큐보다 빠르지만 구현 복잡함 |

---

### 🧠 아이디어 요약
- 덱에는 **현재까지 확인한 인덱스**를 저장한다.
- 덱은 항상 **내림차순(또는 오름차순)** 형태로 유지한다.
- 새로운 값이 들어오면, **덱의 뒤쪽 값이 현재보다 작으면 제거**한다.  
  → 현재 값이 더 강력하므로 그 전에 본 값은 필요 없음!
- 덱의 앞쪽 값이 **슬라이딩 윈도우 범위를 벗어나면 제거**한다.
- 덱의 `First`가 항상 현재 구간의 **최댓값을 가지는 인덱스**가 된다.
- 
---

### 📦 단조 덱 동작 방식 (최댓값 기준)

| 연산 | 설명 |
|------|------|
| `while (arr[deque.Last.Value] <= arr[i])` | 현재 값보다 작거나 같은 값은 뒤에서 제거 |
| `deque.AddLast(i)` | 현재 인덱스 삽입 |
| `if (deque.First.Value <= i - window)` | 윈도우 범위를 벗어난 인덱스는 앞에서 제거 |
| `arr[deque.First.Value]` | 현재 구간의 최댓값 |

> 💡 내림차순 덱을 유지하면, 가장 앞에 항상 **최댓값** 이 위치함

---

### 🧩 구현 시 주의할 점

- **덱 갱신 순서 중요**:  
  삽입 → 정답 추가 → 범위 초과 제거  
  → 현재 값을 포함한 범위에서 정확한 결과 도출 가능

- **범위 계산 주의**:  
  - 슬라이딩 윈도우 범위를 잘 체크해서 계산해야한다.
  - 예시로 슬라이딩 윈도우 크기가 `2m - 1`이라면,  
  - `i >= 2 * m - 2`에서 정답을 추가하고  
  - `deque.First.Value < i - (2m - 2)`이면 제거한다.

---
### 🔍 예시
## 예시 1: 단순한 예시
- 배열: **1 2 3 4 5**
- 윈도우 크기 = 2m - 1 = **3**  
- 윈도우 범위: **[0\~2], [1\~3], [2\~4]**

| i | 현재값 | 덱 상태 (인덱스) | 윈도우 범위 | 덱 front → max값 |
|---|--------|------------------|-------------|------------------|
| 0 | 1      | [0]              | x           | x                |
| 1 | 2      | [1]              | x           | x                |
| 2 | 3      | [2]              | [0~2]       | 3                |
| 3 | 4      | [3]              | [1~3]       | 4                |
| 4 | 5      | [4]              | [2~4]       | 5                |

## 예시 2: 복잡한 예시
- 배열: **11 8 6 4 3 1 15 22 37 5**
- 윈도우 크기 = 2m - 1 = **5**  
- 윈도우 범위: **[0\~4], [1\~5], [2\~6], [3\~7], [4\~8], [5\~9]** 
- 아래 표에 제거된 인덱스를 추가하였는데 현재 값이 더 클경우 **덱 단조(내림차순)** 를 통해 **왼쪽범위**중 **현재값**보다 **작은 값을 제거**함
- 또는 **슬라이딩 윈도우 범위**를 벗어난 경우에도 **해당 인덱스**를 제거함

| i  | 현재값 | 덱 상태 (인덱스) | 제거된 인덱스 | 윈도우 범위 | 덱 front → max값 |
|----|--------|------------------|--------------|-------------|------------------|
| 0  | 11     | [0]              |              | x           | x                |
| 1  | 8      | [0,1]            |              | x           | x                |
| 2  | 6      | [0,1,2]          |              | x           | x                |
| 3  | 4      | [0,1,2,3]        |              | x           | x                |
| 4  | 3      | [0,1,2,3,4]      |              | [0~4]       | 11               |
| 5  | 1      | [1,2,3,4,5]      | [0]          | [1~5]       | 8                |
| 6  | 15     | [6]              | [1,2,3,4,5]  | [2~6]       | 15               |
| 7  | 22     | [7]              | [6]          | [3~7]       | 22               |
| 8  | 37     | [8]              | [7]          | [4~8]       | 37               |
| 9  | 5      | [8,9]            |              | [5~9]       | 37               |


---
### 🔍 단조 덱 관련문제 
## [백준 1306번: 달려라 홍준](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/1306.%E2%80%85%EB%8B%AC%EB%A0%A4%EB%9D%BC%E2%80%85%ED%99%8D%EC%A4%80) (단조덱으로 풀이 시간: 480 ms ⭐)
## [백준 11003번: 최솟값 찾기](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/11003.%E2%80%85%EC%B5%9C%EC%86%9F%EA%B0%92%E2%80%85%EC%B0%BE%EA%B8%B0) (우선순위 큐 풀이 시간: 3092 ms ❗)

---
### ✅ 느낀 점
- 슬라이딩 윈도우 + 범위내 값 찾기 유형에서 빠른 O(N) 풀이가 가능하다!

- 정확한 범위 계산과 동작 순서의 이해가 핵심이다!

- 처음에는 헷갈리지만, 익숙해지면 구간내 최대/ 최소를 구하는 문제에서 효율적으로 사용할수 있다!
