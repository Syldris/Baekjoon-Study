## [백준 3653번: 영화 수집](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/3653.%E2%80%85%EC%98%81%ED%99%94%E2%80%85%EC%88%98%EC%A7%91)
### ✅ 문제 요약
- **문제 유형**: DVD 영화 순서 추적 문제
- **설명**:  
  상근이는 여러 장의 DVD를 쌓아 보관한다.  
  보고 싶은 영화가 있을 때, DVD의 위치를 확인한 뒤, 조심스럽게 해당 DVD를 꺼낸다.  
  영화를 다 본 후에는 DVD를 **맨 위로 올린다**.  

> 문제의 핵심은 매번 DVD를 올릴 때 **위에 몇 장의 DVD가 있는지 효율적으로 계산**하는 것이다.

- **주요 아이디어**:  
  - 각 DVD의 현재 위치를 `pos[i]` 배열에 기록하고, 세그먼트 트리(Segment Tree)를 사용하여 특정 구간에 존재하는 DVD 수를 빠르게 계산한다.
  - M번 DVD를 올리는 만큼 맨 위에 위치할 공간을 미리 0으로 비워두고, DVD들이 실제로 위치한 m+1~m+n 공간을 1로 세팅하여 트리를 초기화한다.
  - 영화 시청 시, `top` 변수를 사용하여 맨 위로 올리는 위치를 관리하고, 각 DVD가 이동할 때마다 Update를 수행한다.

---

### 💡 핵심 개념

## 1. DVD 위치 추적 및 세그먼트 트리 활용
- 각 DVD의 위치를 `pos[i]` 배열에 저장
- 세그먼트 트리 노드 값: 해당 구간에 존재하는 DVD 수
- `Query(node, start, end, left, right)`  
  > 특정 구간에 존재하는 DVD 수 계산
- `Update(node, start, end, index, value)`  
  > DVD가 이동하거나 초기 위치를 세팅할 때 트리 갱신

### 2. 초기화 방법
### 방법 1: N회 Update
- 초기 위치: `pos[i] = m + i`
- 각 위치에 1로 Update
- O(N log N)으로 초기화 가능
- 매번 Update가 반복되므로 속도는 약간 느릴 수 있음

### 방법 2: Build 함수 사용 (추천)
- 원본 배열 `arr` 생성:
  > - 1~m: 0 (M번 올릴 DVD 공간, 빈 공간)  
  > - m+1~m+n: 1 (실제 DVD 위치)
- Build 함수로 한 번에 트리 초기화
- 초기화 속도 **O(N)**
- 영화 시청 시 필요한 위치만 Update
- 이 방법을 처음 접했을 때,  
  > **빌드 함수에서 1~m를 0으로, m+1~m+n을 1로 세운 배열을 만들어 참조한다는 아이디어가 정말 기발하다**고 느꼈다.  
  한 번 이해하고 나니, Update 반복보다 훨씬 효율적이며 깔끔하게 구현할 수 있었다.

## 3. top 변수와 빈 공간 관리
- 1~M 공간은 맨 위로 올릴 DVD들을 위해 0으로 비워둔다
- 영화 시청 시, top 값을 감소시키며 각 DVD를 해당 위치로 이동
- M번 올리는 만큼 공간을 미리 확보 → 충돌 없이 Update 가능

---

# 📝 느낀점
> - 문제 태그를 보기 전까진 세그먼트 트리로 푸는 문제라고 감잡기 어려운 난해한 문제였다.  
> - 첫 풀이에서는 원본 배열을 적절히 참조할 Build 함수를 만들지 못해 Update 함수를 N회 반복했으나, 만족스럽지 않았다.  
> - Build 함수에서 1~m를 0으로, m+1~m+n을 1로 세운 배열을 만들어 참조하게 짜니  
> - Update 반복 방식보다 훨씬 효율적이고 정확하게 동작했다.

### ✅ [최종 코드(C#)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/3653.%E2%80%85%EC%98%81%ED%99%94%E2%80%85%EC%88%98%EC%A7%91)
<details>
<summary><b>영화 수집 C#코드(주석포함) 눌러서 펼쳐보기</b></summary>
  
```csharp
#nullable disable
using System;
using System.Text;
class Program
{
    static void Main()
    {
        using StreamReader sr = new StreamReader(new BufferedStream(Console.OpenStandardInput()));
        using StreamWriter sw = new StreamWriter(new BufferedStream(Console.OpenStandardOutput()));

        int testcase = int.Parse(sr.ReadLine());
        for (int t = 0; t < testcase; t++)
        {
            string[] input = sr.ReadLine().Split();
            int n = int.Parse(input[0]);
            int m = int.Parse(input[1]);

            int size = m + n;

            int[] pos = new int[n + 1];
            int[] tree = new int[size * 4];

            int[] arr = new int[size + 1];
            for (int i = 1; i <= n; i++)
            {
                pos[i] = m + i;
                arr[pos[i]] = 1;
            }

            Build(1, 1, size);
            int[] line = sr.ReadLine().Split().Select(int.Parse).ToArray();
            int top = m;
            for (int i = 0; i < m; i++)
            {
                int value = line[i];
                sw.Write($"{Query(1, 1, size, 1, pos[value] - 1)} ");
                Update(1, 1, size, pos[value], 0);
                pos[value] = top;
                Update(1, 1, size, top--, 1);
            }
            sw.WriteLine();
            int Build(int node, int start, int end)
            {
                if (start == end)
                {
                    return tree[node] = arr[start];
                }
                int mid = (start + end) / 2;

                return tree[node] = Build(node * 2, start, mid) + Build(node * 2 + 1, mid + 1, end);
            }

            void Update(int node, int start, int end, int index, int value)
            {
                if (index < start || index > end)
                {
                    return;
                }

                if (start == end)
                {
                    tree[node] = value;
                    return;
                }

                int mid = (start + end) / 2;

                if (index <= mid)
                {
                    Update(node * 2, start, mid, index, value);
                }
                else
                {
                    Update(node * 2 + 1, mid + 1, end, index, value);
                }

                tree[node] = tree[node * 2] + tree[node * 2 + 1];
            }

            int Query(int node, int start, int end, int left, int right)
            {
                if (start > right || end < left)
                {
                    return 0;
                }
                if (left <= start && end <= right)
                {
                    return tree[node];
                }
                int mid = (start + end) / 2;

                return Query(node * 2, start, mid, left, right) + Query(node * 2 + 1, mid + 1, end, left, right);
            }
        }
    }
}
```

</details>
