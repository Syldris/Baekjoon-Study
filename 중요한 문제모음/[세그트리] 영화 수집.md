## [ë°±ì¤€ 3653ë²ˆ: ì˜í™” ìˆ˜ì§‘](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/3653.%E2%80%85%EC%98%81%ED%99%94%E2%80%85%EC%88%98%EC%A7%91)
### âœ… ë¬¸ì œ ìš”ì•½
- **ë¬¸ì œ ìœ í˜•**: DVD ì˜í™” ìˆœì„œ ì¶”ì  ë¬¸ì œ
- **ì„¤ëª…**:  
  ìƒê·¼ì´ëŠ” ì—¬ëŸ¬ ì¥ì˜ DVDë¥¼ ìŒ“ì•„ ë³´ê´€í•œë‹¤.  
  ë³´ê³  ì‹¶ì€ ì˜í™”ê°€ ìˆì„ ë•Œ, DVDì˜ ìœ„ì¹˜ë¥¼ í™•ì¸í•œ ë’¤, ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ í•´ë‹¹ DVDë¥¼ êº¼ë‚¸ë‹¤.  
  ì˜í™”ë¥¼ ë‹¤ ë³¸ í›„ì—ëŠ” DVDë¥¼ **ë§¨ ìœ„ë¡œ ì˜¬ë¦°ë‹¤**.  

> ë¬¸ì œì˜ í•µì‹¬ì€ ë§¤ë²ˆ DVDë¥¼ ì˜¬ë¦´ ë•Œ **ìœ„ì— ëª‡ ì¥ì˜ DVDê°€ ìˆëŠ”ì§€ íš¨ìœ¨ì ìœ¼ë¡œ ê³„ì‚°**í•˜ëŠ” ê²ƒì´ë‹¤.

- **ì£¼ìš” ì•„ì´ë””ì–´**:  
  - ê° DVDì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ `pos[i]` ë°°ì—´ì— ê¸°ë¡í•˜ê³ , ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(Segment Tree)ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • êµ¬ê°„ì— ì¡´ì¬í•˜ëŠ” DVD ìˆ˜ë¥¼ ë¹ ë¥´ê²Œ ê³„ì‚°í•œë‹¤.
  - Më²ˆ DVDë¥¼ ì˜¬ë¦¬ëŠ” ë§Œí¼ ë§¨ ìœ„ì— ìœ„ì¹˜í•  ê³µê°„ì„ ë¯¸ë¦¬ 0ìœ¼ë¡œ ë¹„ì›Œë‘ê³ , DVDë“¤ì´ ì‹¤ì œë¡œ ìœ„ì¹˜í•œ m+1~m+n ê³µê°„ì„ 1ë¡œ ì„¸íŒ…í•˜ì—¬ íŠ¸ë¦¬ë¥¼ ì´ˆê¸°í™”í•œë‹¤.
  - ì˜í™” ì‹œì²­ ì‹œ, `top` ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë§¨ ìœ„ë¡œ ì˜¬ë¦¬ëŠ” ìœ„ì¹˜ë¥¼ ê´€ë¦¬í•˜ê³ , ê° DVDê°€ ì´ë™í•  ë•Œë§ˆë‹¤ Updateë¥¼ ìˆ˜í–‰í•œë‹¤.

---

### ğŸ’¡ í•µì‹¬ ê°œë…

## 1. DVD ìœ„ì¹˜ ì¶”ì  ë° ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ í™œìš©
- ê° DVDì˜ ìœ„ì¹˜ë¥¼ `pos[i]` ë°°ì—´ì— ì €ì¥
- ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ë…¸ë“œ ê°’: í•´ë‹¹ êµ¬ê°„ì— ì¡´ì¬í•˜ëŠ” DVD ìˆ˜
- `Query(node, start, end, left, right)`  
  > íŠ¹ì • êµ¬ê°„ì— ì¡´ì¬í•˜ëŠ” DVD ìˆ˜ ê³„ì‚°
- `Update(node, start, end, index, value)`  
  > DVDê°€ ì´ë™í•˜ê±°ë‚˜ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì„¸íŒ…í•  ë•Œ íŠ¸ë¦¬ ê°±ì‹ 

### 2. ì´ˆê¸°í™” ë°©ë²•
### ë°©ë²• 1: NíšŒ Update
- ì´ˆê¸° ìœ„ì¹˜: `pos[i] = m + i`
- ê° ìœ„ì¹˜ì— 1ë¡œ Update
- O(N log N)ìœ¼ë¡œ ì´ˆê¸°í™” ê°€ëŠ¥
- ë§¤ë²ˆ Updateê°€ ë°˜ë³µë˜ë¯€ë¡œ ì†ë„ëŠ” ì•½ê°„ ëŠë¦´ ìˆ˜ ìˆìŒ

### ë°©ë²• 2: Build í•¨ìˆ˜ ì‚¬ìš© (ì¶”ì²œ)
- ì›ë³¸ ë°°ì—´ `arr` ìƒì„±:
  > - 1~m: 0 (Më²ˆ ì˜¬ë¦´ DVD ê³µê°„, ë¹ˆ ê³µê°„)  
  > - m+1~m+n: 1 (ì‹¤ì œ DVD ìœ„ì¹˜)
- Build í•¨ìˆ˜ë¡œ í•œ ë²ˆì— íŠ¸ë¦¬ ì´ˆê¸°í™”
- ì´ˆê¸°í™” ì†ë„ **O(N)**
- ì˜í™” ì‹œì²­ ì‹œ í•„ìš”í•œ ìœ„ì¹˜ë§Œ Update
- ì´ ë°©ë²•ì„ ì²˜ìŒ ì ‘í–ˆì„ ë•Œ,  
  > **ë¹Œë“œ í•¨ìˆ˜ì—ì„œ 1~më¥¼ 0ìœ¼ë¡œ, m+1~m+nì„ 1ë¡œ ì„¸ìš´ ë°°ì—´ì„ ë§Œë“¤ì–´ ì°¸ì¡°í•œë‹¤ëŠ” ì•„ì´ë””ì–´ê°€ ì •ë§ ê¸°ë°œí•˜ë‹¤**ê³  ëŠê¼ˆë‹¤.  
  í•œ ë²ˆ ì´í•´í•˜ê³  ë‚˜ë‹ˆ, Update ë°˜ë³µë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì´ë©° ê¹”ë”í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆì—ˆë‹¤.

## 3. top ë³€ìˆ˜ì™€ ë¹ˆ ê³µê°„ ê´€ë¦¬
- 1~M ê³µê°„ì€ ë§¨ ìœ„ë¡œ ì˜¬ë¦´ DVDë“¤ì„ ìœ„í•´ 0ìœ¼ë¡œ ë¹„ì›Œë‘”ë‹¤
- ì˜í™” ì‹œì²­ ì‹œ, top ê°’ì„ ê°ì†Œì‹œí‚¤ë©° ê° DVDë¥¼ í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™
- Më²ˆ ì˜¬ë¦¬ëŠ” ë§Œí¼ ê³µê°„ì„ ë¯¸ë¦¬ í™•ë³´ â†’ ì¶©ëŒ ì—†ì´ Update ê°€ëŠ¥

---

# ğŸ“ ëŠë‚€ì 
> - ë¬¸ì œ íƒœê·¸ë¥¼ ë³´ê¸° ì „ê¹Œì§„ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¡œ í‘¸ëŠ” ë¬¸ì œë¼ê³  ê°ì¡ê¸° ì–´ë ¤ìš´ ë‚œí•´í•œ ë¬¸ì œì˜€ë‹¤.  
> - ì²« í’€ì´ì—ì„œëŠ” ì›ë³¸ ë°°ì—´ì„ ì ì ˆíˆ ì°¸ì¡°í•  Build í•¨ìˆ˜ë¥¼ ë§Œë“¤ì§€ ëª»í•´ Update í•¨ìˆ˜ë¥¼ NíšŒ ë°˜ë³µí–ˆìœ¼ë‚˜, ë§Œì¡±ìŠ¤ëŸ½ì§€ ì•Šì•˜ë‹¤.  
> - Build í•¨ìˆ˜ì—ì„œ 1~më¥¼ 0ìœ¼ë¡œ, m+1~m+nì„ 1ë¡œ ì„¸ìš´ ë°°ì—´ì„ ë§Œë“¤ì–´ ì°¸ì¡°í•˜ê²Œ ì§œë‹ˆ  
> - Update ë°˜ë³µ ë°©ì‹ë³´ë‹¤ í›¨ì”¬ íš¨ìœ¨ì ì´ê³  ì •í™•í•˜ê²Œ ë™ì‘í–ˆë‹¤.

### âœ… [ìµœì¢… ì½”ë“œ(C#)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/3653.%E2%80%85%EC%98%81%ED%99%94%E2%80%85%EC%88%98%EC%A7%91)
<details>
<summary><b>ì˜í™” ìˆ˜ì§‘ C#ì½”ë“œ(ì£¼ì„í¬í•¨) ëˆŒëŸ¬ì„œ í¼ì³ë³´ê¸°</b></summary>
  
```csharp
#nullable disable
using System;
using System.Text;
class Program
{
    static void Main()
    {
        using StreamReader sr = new StreamReader(new BufferedStream(Console.OpenStandardInput()));
        using StreamWriter sw = new StreamWriter(new BufferedStream(Console.OpenStandardOutput()));

        int testcase = int.Parse(sr.ReadLine());
        for (int t = 0; t < testcase; t++)
        {
            string[] input = sr.ReadLine().Split();
            int n = int.Parse(input[0]);
            int m = int.Parse(input[1]);

            int size = m + n;

            int[] pos = new int[n + 1];
            int[] tree = new int[size * 4];

            int[] arr = new int[size + 1];
            for (int i = 1; i <= n; i++)
            {
                pos[i] = m + i;
                arr[pos[i]] = 1;
            }

            Build(1, 1, size);
            int[] line = sr.ReadLine().Split().Select(int.Parse).ToArray();
            int top = m;
            for (int i = 0; i < m; i++)
            {
                int value = line[i];
                sw.Write($"{Query(1, 1, size, 1, pos[value] - 1)} ");
                Update(1, 1, size, pos[value], 0);
                pos[value] = top;
                Update(1, 1, size, top--, 1);
            }
            sw.WriteLine();
            int Build(int node, int start, int end)
            {
                if (start == end)
                {
                    return tree[node] = arr[start];
                }
                int mid = (start + end) / 2;

                return tree[node] = Build(node * 2, start, mid) + Build(node * 2 + 1, mid + 1, end);
            }

            void Update(int node, int start, int end, int index, int value)
            {
                if (index < start || index > end)
                {
                    return;
                }

                if (start == end)
                {
                    tree[node] = value;
                    return;
                }

                int mid = (start + end) / 2;

                if (index <= mid)
                {
                    Update(node * 2, start, mid, index, value);
                }
                else
                {
                    Update(node * 2 + 1, mid + 1, end, index, value);
                }

                tree[node] = tree[node * 2] + tree[node * 2 + 1];
            }

            int Query(int node, int start, int end, int left, int right)
            {
                if (start > right || end < left)
                {
                    return 0;
                }
                if (left <= start && end <= right)
                {
                    return tree[node];
                }
                int mid = (start + end) / 2;

                return Query(node * 2, start, mid, left, right) + Query(node * 2 + 1, mid + 1, end, left, right);
            }
        }
    }
}
```

</details>
