# ✅ 문제 요약
- **문제 유형**: DVD 영화 순서 추적 문제
- **설명**:  
  상근이는 여러 장의 DVD를 쌓아 보관한다.  
  보고 싶은 영화가 있을 때, DVD의 위치를 확인한 뒤, 조심스럽게 해당 DVD를 꺼낸다.  
  영화를 다 본 후에는 DVD를 **맨 위로 올린다**.  

> 문제의 핵심은 매번 DVD를 올릴 때 **위에 몇 장의 DVD가 있는지 효율적으로 계산**하는 것이다.

- **주요 아이디어**:  
  - 각 DVD의 현재 위치를 `pos[i]` 배열에 기록하고, 세그먼트 트리(Segment Tree)를 사용하여 특정 구간에 존재하는 DVD 수를 빠르게 계산한다.
  - M번 DVD를 올리는 만큼 맨 위에 위치할 공간을 미리 0으로 비워두고, DVD들이 실제로 위치한 m+1~m+n 공간을 1로 세팅하여 트리를 초기화한다.
  - 영화 시청 시, `top` 변수를 사용하여 맨 위로 올리는 위치를 관리하고, 각 DVD가 이동할 때마다 Update를 수행한다.

---

# 💡 핵심 개념

## 1. DVD 위치 추적 및 세그먼트 트리 활용
- 각 DVD의 위치를 `pos[i]` 배열에 저장
- 세그먼트 트리 노드 값: 해당 구간에 존재하는 DVD 수
- `Query(node, start, end, left, right)`  
  > 특정 구간에 존재하는 DVD 수 계산
- `Update(node, start, end, index, value)`  
  > DVD가 이동하거나 초기 위치를 세팅할 때 트리 갱신

## 2. 초기화 방법
### 방법 1: N회 Update
- 초기 위치: `pos[i] = m + i`
- 각 위치에 1로 Update
- O(N log N)으로 초기화 가능
- 매번 Update가 반복되므로 속도는 약간 느릴 수 있음

### 방법 2: Build 함수 사용 (추천)
- 원본 배열 `arr` 생성:
  > - 1~m: 0 (M번 올릴 DVD 공간, 빈 공간)  
  > - m+1~m+n: 1 (실제 DVD 위치)
- Build 함수로 한 번에 트리 초기화
- 초기화 속도 **O(N)**
- 영화 시청 시 필요한 위치만 Update
- 이 방법을 처음 접했을 때,  
  > **빌드 함수에서 1~m를 0으로, m+1~m+n을 1로 세운 배열을 만들어 참조한다는 아이디어가 정말 기발하다**고 느꼈다.  
  한 번 이해하고 나니, Update 반복보다 훨씬 효율적이며 깔끔하게 구현할 수 있었다.

## 3. top 변수와 빈 공간 관리
- 1~M 공간은 맨 위로 올릴 DVD들을 위해 0으로 비워둔다
- 영화 시청 시, top 값을 감소시키며 각 DVD를 해당 위치로 이동
- M번 올리는 만큼 공간을 미리 확보 → 충돌 없이 Update 가능

---

# 📝 느낀점
> - 문제 태그를 보기 전까진 세그먼트 트리로 푸는 문제라고 감잡기 어려운 난해한 문제였다.  
> - 첫 풀이에서는 원본 배열을 적절히 참조할 Build 함수를 만들지 못해 Update 함수를 N회 반복했으나, 만족스럽지 않았다.  
> - Build 함수에서 1~m를 0으로, m+1~m+n을 1로 세운 배열을 만들어 참조하게 짜니  
> - Update 반복 방식보다 훨씬 효율적이고 정확하게 동작했다.
