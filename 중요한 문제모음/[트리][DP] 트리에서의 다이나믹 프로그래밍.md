# ✅ 트리에서의 다이나믹 프로그래밍 (Tree DP)

## ✅ 개념 요약

- 트리 구조에서 **각 정점을 기준으로 부분 문제를 정의하고 해결하는 DP 기법**이다.
- 트리는 **사이클이 없고 부모-자식 관계가 명확**하기 때문에,
- 보통 **DFS를 이용하여 자식부터 계산하여 부모의 값을 결정**하는 방식이 자연스럽고 효율적이다.

핵심 요약:

> **자식의 결과를 먼저 계산한 뒤, 그 결과로 부모의 DP 상태를 완성한다.**
---

## 🌳 트리의 기본 특징

- 사이클이 없고 모든 정점이 연결된 그래프
- 간선 수는 항상 `N-1`

### 무방향 트리 (Undirected Tree)

- **어느 정점을 루트로 잡아도 상관 없음**
- 문제에 따라 보통 1번 정점 또는 임의의 정점을 루트로 선택

### 방향 트리 / 루트 트리 (Directed / Rooted Tree)

- 부모 → 자식 방향이 **입력으로 주어지는 트리**
- 부모가 없는 정점이 자연스럽게 루트가 된다
- 방향이 이미 정해져 있으므로, 간선 추가시 단방향만 추가

---

## ✅ 왜 Tree DP를 사용하는가?

트리 문제는 단순한 그래프 탐색(DFS/BFS)만으로는 해결되지 않는 경우가 많다.

특히 다음과 같은 조건이 붙는 문제에서 일반 탐색으로는 한계가 생긴다.

- 각 정점의 선택 여부에 따라 주변 정점의 선택이 제한되는 경우
- 경로가 아니라 **서브트리 전체를 기준으로 계산해야 하는 경우**
- 모든 정점을 방문하면서도 **최적해(최대/최소)를 동시에 계산해야 하는 경우**

일반적인 DFS/BFS는  
“방문 순서”만 관리할 뿐, **이미 계산한 부분 결과를 재사용하지 않는다.**

반면 Tree DP는

> 각 정점의 결과를 저장해 두고,  
> 그 값을 부모 정점에서 다시 활용하면서  
> **전체 트리의 최적해**를 효율적으로 구한다.

따라서 Tree DP는 다음과 같은 장점이 있다.
- **중복 계산을 줄일 수 있다**
- **서브트리 단위로 값을 계산할 수 있다**
- **탐색 + 최적화를 동시에 처리할 수 있다**

---

## ⏱️ 시간·공간 복잡도

* **시간 복잡도**: `O(N)`

  * 각 정점을 한 번씩 방문해서 값을 계산하므로 선형 시간.
* **공간 복잡도**: `O(N)`

  * 인접 리스트, DP 테이블, 구조체 등 사용.

> 참고: 트리에서는 간선 수가 `N-1`이므로 DFS/BFS 기반 처리 비용은 모두 `O(N)`을 기준으로 본다.

---

## 🧠 동작 원리(작동 흐름)

1. 루트 하나를 정한다(보통 1번 정점).
2. DFS로 **자식 노드부터 먼저** 내려가서 계산한다(후위 순회 / post-order).
3. 각 노드에서 자식들의 DP값을 모아 자신의 DP값을 계산한다.
4. 루트의 DP 값으로 답을 얻거나, 루트 기준으로 도출한 값을 사용해 답을 얻는다.

> 핵심: 부모는 자식의 계산이 끝난 이후에야 자신의 값을 정확히 정할 수 있다.

---

## 🧩 DP 상태 정의

문제 유형에 따라 상태 정의는 달라지지만, 문제에서 자주 보이는 패턴은 다음과 같다.

* `dp[node][0]` : 해당 정점을 **선택하지 않았을 때**의 최적값
* `dp[node][1]` : 해당 정점을 **선택했을 때**의 최적값

이 패턴은 특히 **인접 정점 동시 선택 금지** 또는 **독립 집합** 유형 문제에서 자주 사용된다.

점화식(직관적인 요약):

* `dp[node][1] + dp[child][0]` → 현재 정점을 선택했으므로 **자식은 전부 비선택 상태만 가능**
* `Max(dp[node][0] + dp[child][0], dp[node][0] + dp[child][1])`
*  → 현재 정점을 선택하지 않았으므로  각 자식은 **선택 / 비선택 중 최대값을 자유롭게 선택 가능**

일반식(문장으로 표현):

> 부모를 선택하면 자식은 무조건 선택 불가 상태가 된다.  
> 부모를 선택하지 않으면 자식은 각자 선택/비선택 중 최적의 상태를 고를 수 있다.

---

## ✅ 자주 쓰이는 상태/점화식의 예시(문제 유형별 포인트)

* **가중치 있는 독립 집합(우수 마을)**

  * 상태: 선택/비선택 2가지
  * 점화식: 위의 전형 패턴 그대로 적용
  * 구조: “부모 선택 시 자식 비선택 강제” 구조

* **서브트리의 정점 갯수**

  * 상태: 서브트리에 포함된 정점 개수
  * 점화식: 부모는 자식 서브트리 정점을 합산

> 핵심은 “서브트리 단위로 어떤 값을 저장할지 결정하는 것”이다.

---

## ⚠️ 실수하기 쉬운 부분

1. **부모로 다시 돌아가는 무한 루프**

   * 원인: 부모 체크 없이 DFS 재귀 호출
   * 해결: DFS 호출 시 `if child == parent continue` 또는 `visited` 사용

2. **자료형(타입) 부족으로 오버플로 발생**

   * 원인: 합으로 값이 커지는 문제에서 int 사용
   * 해결: long(64bit) 등으로 자료형 키우기

3. **부분 문제 중복 계산**

   * 원인: 잘못된 재귀 구조(같은 서브트리를 여러 번 계산)
   * 해결: 각 정점을 정확히 한 번만 처리하도록 DFS 설계

---

## ✅ 실전 전략 (문제 풀 때 순서)

1. 문제를 읽고 **dp에 무엇을 저장할지** 먼저 고려한다.

   * 예: "dp[u][0] 은 u를 선택하지 않았을 때 u의 서브트리에서 얻을 수 있는 최대 이익"

2. 각 상태에 대한 **점화식**을 생각한다.

   * 예: "`dp[u][1]`를 선택한다면 u의 모든 자식 v는 `dp[v][0]`만 가능"

3. 트리에서 루트로 고정하고 **후위 DFS** 흐름을 그린다.

4. 구현(인접리스트, dp 배열, DFS)

---

## ✅ 언제 Tree DP를 사용해야 할까?

* 그래프가 트리(간선 = N-1, 연결 그래프)일 때
* 문제 설명에 **부모-자식 관계/서브트리**가 자연스럽게 등장할 때
* 각 정점이 독립적으로 어떤 값을 가지며, **그 값이 자식들의 값으로부터 계산 가능**할 때

---

## ✅ 마무리

* Tree DP는 “자식 결과 합쳐서 부모 계산”이라는 규칙만 정확히 이해하면 강력하다.
* 상태 정의가 문제 해결의 핵심이며, 점화식은 정의된 DP 상태를 기반으로 구성할 수 있다.
* 부모 체크, 자료형, 방문 처리만 잘하면 대부분의 구현 버그는 막을 수 있다.
