# ✅ 트리에서의 다이나믹 프로그래밍 (Tree DP)

## ✅ 개념 요약

- 트리 구조에서 **각 정점을 기준으로 부분 문제를 정의하고 해결하는 DP 기법**이다.
- 트리는 **사이클이 없고 부모-자식 관계가 명확**하기 때문에,
- 보통 **DFS를 이용하여 자식부터 계산하여 부모의 값을 결정**하는 방식이 자연스럽고 효율적이다.
 
핵심 요약:

> **자식의 결과를 먼저 계산한 뒤, 그 결과로 부모의 DP 상태를 완성한다.**
---

## 🌳 트리의 기본 특징

- 사이클이 없고 모든 정점이 연결된 그래프
- 간선 수는 항상 `N-1`

### 무방향 트리 (Undirected Tree)

- **어느 정점을 루트로 잡아도 상관 없음**
- 문제에 따라 보통 1번 정점 또는 임의의 정점을 루트로 선택

### 방향 트리 / 루트 트리 (Directed / Rooted Tree)

- 부모 → 자식 방향이 **입력으로 주어지는 트리**
- 부모가 없는 정점이 자연스럽게 루트가 된다
- 방향이 이미 정해져 있으므로, 간선 추가시 단방향만 추가

---

## ✅ 왜 Tree DP를 사용하는가?

트리 문제는 단순한 그래프 탐색(DFS/BFS)만으로는 해결되지 않는 경우가 많다.

특히 다음과 같은 조건이 붙는 문제에서 일반 탐색으로는 한계가 생긴다.

- 각 정점의 선택 여부에 따라 주변 정점의 선택이 제한되는 경우
- 경로가 아니라 **서브트리 전체를 기준으로 계산해야 하는 경우**
- 모든 정점을 방문하면서도 **최적해(최대/최소)를 동시에 계산해야 하는 경우**

일반적인 DFS/BFS는  
“방문 순서”만 관리할 뿐, **이미 계산한 부분 결과를 재사용하지 않는다.**

반면 Tree DP는

> 각 정점의 결과를 저장해 두고,  
> 그 값을 부모 정점에서 다시 활용하면서  
> **전체 트리의 최적해**를 효율적으로 구한다.

따라서 Tree DP는 다음과 같은 장점이 있다.
- **중복 계산을 줄일 수 있다.**
- **서브트리 단위로 값을 계산할 수 있다.**
- **탐색 + 최적화를 동시에 처리할 수 있다.**

---

## ✅ 언제 Tree DP를 사용해야 할까? 

* 그래프가 트리(간선 = N-1, 연결 그래프)일 때
* 문제 설명에 **부모-자식 관계/서브트리**가 자연스럽게 등장할 때
* 각 정점이 독립적으로 어떤 값을 가지며, **그 값이 자식들의 값으로부터 계산 가능**할 때

---


## ⏱️ 시간·공간 복잡도

* **시간 복잡도**: `O(N)`

  * 각 정점을 한 번씩 방문해서 값을 계산하므로 선형 시간
* **공간 복잡도**: `O(N)`

  * 인접 리스트, DP 테이블, 구조체 등 사용.

> 참고: 트리에서는 간선 수가 `N-1`이므로 DFS/BFS 기반 처리 비용은 모두 `O(N)`을 기준으로 본다.

---

## 🧠 동작 원리(작동 흐름)

1. 루트 하나를 정한다(보통 1번 정점).
2. DFS로 **자식 노드부터 먼저** 내려가서 계산한다(후위 순회 / post-order).
3. 각 노드에서 자식들의 DP값을 모아 자신의 DP값을 계산한다.
4. 루트의 DP 값으로 답을 얻거나, 루트 기준으로 도출한 값을 사용해 답을 얻는다.

> 핵심: 이 DP 값들은 **“현재 정점을 루트로 하는 서브트리만”** 을 고려한 **부분 최적해**이며,
> 
> **루트 노드**까지 계산이 완료되면 **트리 전체에 대한 최적해**를 얻을 수 있다.

---

## 🔍 트리에서의 다이나믹 프로그래밍 관련 문제
> 트리 구조에서 다이나믹 프로그래밍(DP)을 적용하는 문제들을 정리함

### 🧩 가중치 있는 독립 집합 (Weighted Independent Set)

트리에서 **인접한 정점을 동시에 선택할 수 없을때, 
선택한 정점들의 가중치합이 최대가 되도록 선택하는** 문제 유형

### 📌 관련 문제

- #### [백준 1949번: 우수 마을](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/1949.%E2%80%85%EC%9A%B0%EC%88%98%E2%80%85%EB%A7%88%EC%9D%84)
- #### [백준 2213번: 트리의 독립집합](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/2213.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%9D%98%E2%80%85%EB%8F%85%EB%A6%BD%EC%A7%91%ED%95%A9)

#### 💡 핵심 아이디어

**DP 상태 정의**
* `dp[node][0]` : node를 루트로 하는 서브트리에서, node를 선택하지 않았을 때 얻을 수 있는 최대값
* `dp[node][1]` : node를 루트로 하는 서브트리에서, node를 선택했을 때 얻을 수 있는 최대값
* 부모 정점을 선택하면 자식은 부모와 인접하므로 **무조건 선택 불가**

**점화식**
``` cs
dp[node][0] = 0;                                 // 현재 노드를 선택하지 않은 경우
dp[node][1] = arr[node];                        // 현재 노드를 선택한 경우
dp[node][0] += Max(dp[child][0], dp[child][1]) // 현재 노드를 선택하지 않은 경우에는 자식의 선택/ 미선택 값중 큰값을 취함
dp[node][1] += dp[child][0]                   // 현재 노드를 선택한 경우에는 자식은 반드시 미선택만 가능함
```

**점화식 해석**
* `Max(dp[node][0] + dp[child][0], dp[node][0] + dp[child][1])`
*  → 현재 정점을 선택하지 않았으므로  각 자식은 **선택 / 비선택 중 최대값을 자유롭게 선택 가능**
* `dp[node][1] + dp[child][0]` → 현재 정점을 선택했으므로 **자식은 전부 비선택 상태만 가능**

**핵심 규칙**

> 부모를 선택하면 자식은 부모와 인접하기에 무조건 선택 불가 상태가 된다.  
> 부모를 선택하지 않으면 자식은 각자 선택/비선택 중 최적의 상태를 고를 수 있다.

✅ **역추적 가능**: 실제 선택된 정점 목록 복원 가능 (2213번)

---

### 🌳 서브트리 크기(정점 수) 계산 유형

트리에서 **특정 정점을 기준으로, 그 아래에 포함되는 정점의 개수를 구하는 패턴**

### 📌 관련 문제

- #### [백준 15681번: 트리와 쿼리](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/15681.%E2%80%85%ED%8A%B8%EB%A6%AC%EC%99%80%E2%80%85%EC%BF%BC%EB%A6%AC)

#### 💡 핵심 아이디어

**DP 상태 정의**
  - `dp[node]` → 해당 정점을 루트로 하는 **서브트리의 정점 개수**

**점화식**
```cs
dp[node] = 1          // 자기자신은 1
dp[node] += dp[child] // 자식 노드 크기 추가 
```

---

## ⚠️ 실수하기 쉬운 부분

1. **부모로 다시 돌아가는 무한 루프**

   * 원인: 부모 체크 없이 DFS 재귀 호출
   * 해결: DFS 호출 시 `if child == parent continue` 또는 `visited` 사용

2. **자료형(타입) 부족으로 오버플로 발생**

   * 원인: 합으로 값이 커지는 문제에서 int 사용
   * 해결: long(64bit) 등으로 자료형 키우기

3. **부분 문제 중복 계산**

   * 원인: 잘못된 재귀 구조(같은 서브트리를 여러 번 계산)
   * 해결: 각 정점을 정확히 한 번만 처리하도록 DFS 설계

---

## ✅ 실전 전략 (문제 풀 때 순서)

1. 문제를 읽고 **dp에 무엇을 저장할지** 먼저 고려한다.

   * 예: "dp[u][0] 은 u를 선택하지 않았을 때 u의 서브트리에서 얻을 수 있는 최대 이익"

2. 각 상태에 대한 **점화식**을 생각한다.

   * 예: "`dp[u][1]`를 선택한다면 u의 모든 자식 v는 `dp[v][0]`만 가능"

3. 트리에서 루트로 고정하고 **후위 DFS** 흐름을 그린다.

4. 구현(인접리스트, dp 배열, DFS)

---

## ✅ 마무리

* Tree DP는 “자식 결과 합쳐서 부모 계산”이라는 규칙만 정확히 이해하면 강력하다.
* DP 상태 정의가 문제 해결의 핵심이며, 점화식은 정의된 DP 상태를 기반으로 구성할 수 있다.
* 부모 체크, 자료형, 방문 처리만 잘하면 대부분의 구현 버그는 막을 수 있다.
