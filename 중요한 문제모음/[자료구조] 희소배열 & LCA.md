# 희소 배열 (Sparse Table) & LCA (Lowest Common Ancestor)

## 개념 요약

- **희소 배열(Sparse Table)**은 **2의 거듭제곱 간격으로 정보를 저장**하여, 빠른 점프 연산을 가능하게 하는 자료구조이다.
- 트리에서는 **각 정점의 2^k번째 조상을 미리 계산**해두어, **최소 공통 조상(LCA)을 O(log N) 시간에 찾을 수 있다.**
- 모든 수는 **2의 거듭제곱의 합으로 유일하게 표현 가능**하며(이진법), 이를 활용해 **log N번의 점프만으로 모든 쿼리를 처리**할 수 있다.

핵심 요약:

> **2진법 분해를 이용해 O(N) 연산을 O(log N)으로 줄인다.**

---

## 🎯 희소 배열의 기본 원리

### 왜 "희소(Sparse)"인가?

- **일반 배열**: 모든 값을 저장 (0, 1, 2, 3, ..., N-1)
- **희소 배열**: 2의 거듭제곱 위치만 저장 (1, 2, 4, 8, 16, 32, ...)

```
일반: arr[0], arr[1], arr[2], ..., arr[99]     (100개)
희소: sparse[1], sparse[2], sparse[4], sparse[8], sparse[16], ...  (7개)
```

**핵심**: 
- 모든 정보를 저장하지 않아도 **중요한 정보만으로 모든 쿼리에 답 가능**
- 메모리 ↓, 속도 ↑

### 2의 거듭제곱을 사용하는 이유

**수학적 기반: 이진 표현의 유일성**

모든 양의 정수는 **유일하게** 2의 거듭제곱의 합으로 표현된다.

```
19 = 16 + 2 + 1
   = 2^4 + 2^1 + 2^0
   = 10011₂ (이진법)

1,000,000,000 = 2^29 + 2^28 + 2^27 + ...
              = 최대 30개 항
```

**장점**:
- 1~N까지 가려면 최대 log₂(N)번 점프만 필요
- 메모리: N개 → log N개 (90% 이상 절약!)

---

## ⏱️ 시간·공간 복잡도

### 시간 복잡도

- **전처리**: `O(N log N)`
  - DFS로 부모/레벨 계산: `O(N)`
  - 희소 배열 구축: `O(N log N)`
- **쿼리**: `O(log N)`
- **M개 쿼리**: `O(N log N + M log N)`

### 공간 복잡도

```
sparse[N][log N]

N = 100,000
log N ≈ 17

메모리: 100,000 × 17 × 4바이트 ≈ 6.8MB
```

---

## 💡 동작 원리

### 희소 배열 구축

**DP 상태 정의**
- `sparse[node][k]` = node의 2^k번째 조상
- `level[node]` = 루트로부터의 깊이

**점화식**
```cs
// 1단계: 1번째 조상 (부모) 저장
sparse[node, 0] = parent;

// 2단계: 2^k번째 조상 계산
sparse[node, k] = sparse[sparse[node, k-1], k-1];
```

**점화식 해석**

```
2^k번째 조상 = (2^(k-1)번째 조상)의 (2^(k-1)번째 조상)

예: 8번째 조상
8 = 4 + 4 
8번째(k) 조상 = 4번째(k-1) 조상의 4번째(k-1) 조상

sparse[node, 3] = sparse[sparse[node, 2], 2]          //2^3 8번이동은 4번이동한 자리에서 추가로 4번이동
└──[8칸이동)──┘           └─[4칸이동)─┘ └[4칸이동)┘
```

---

## 🔍 희소 배열 관련 문제

### 🧩 LCA (최소 공통 조상)

트리에서 **두 정점의 가장 가까운 공통 조상을 찾는** 문제 유형

#### 📌 관련 문제

- **[백준 11437번: LCA](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11437.%E2%80%85LCA)** - 기본 LCA
- **[백준 11438번: LCA 2](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/11438.%E2%80%85LCA%E2%80%852)** - 쿼리 개수가 많아 logN에 구해야하는 LCA

#### 💡 핵심 아이디어

**알고리즘 흐름**

**1단계: 레벨 맞추기**
```cs
// 더 깊은 노드를 위로 올림
if (level[a] < level[b])
    (a, b) = (b, a);

int diff = level[a] - level[b];

// diff를 2진법으로 분해하며 점프
for (int k = 0; k < maxLog; k++)
{
    if ((diff & (1 << k)) != 0)  // k번째 비트가 1
    {
        a = sparse[a, k];  // 2^k번 점프
    }
}
```

**2단계: 같이 올라가기**
```cs
if (a == b)
    return a;  // 이미 만남

// 큰 점프부터 시도함
// 같은 조상으로 점프하면 LCA를 넘어가므로 X
for (int k = maxLog - 1; k >= 0; k--)
{
    if (sparse[a, k] != sparse[b, k])  // 아직 안 만남 
    {
        a = sparse[a, k];
        b = sparse[b, k];
    }
}

return sparse[a, 0];  // a와 b는 서로 다르지만 부모가 같은 상태이므로, 그 부모가 LCA이다.
```

**핵심 규칙**

> **"다르면 올라가도 됨, 같으면 넘어감"**
> 
> **부모가 다를 때까지만 최대한 점프하고, 부모가 같아지는 순간 바로 아래에서 멈춘 뒤 한 칸 위(부모)로 올라간다.** 
> - `sparse[a][k] != sparse[b][k]` → 2^k번 올라가도 아직 안 만남 → 안전하게 올라감
> - `sparse[a][k] == sparse[b][k]` → 2^k번 올라가면 LCA를 넘어감 → 올라가면 안 됨
---

### 🌳 정점들의 거리 계산

트리에서 **두 정점 사이의 거리(간선 개수 또는 가중치 합)를 구하는** 문제 유형

#### 📌 관련 문제

- **[백준 1761번: 정점들의 거리](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/1761.%E2%80%85%EC%A0%95%EC%A0%90%EB%93%A4%EC%9D%98%E2%80%85%EA%B1%B0%EB%A6%AC)**

#### 💡 핵심 아이디어

**DP 상태 정의**
- `dist[node]` = 루트에서 node까지의 거리

**거리 계산 공식**
```cs
dist(a, b) = dist[a] + dist[b] - 2 × dist[LCA(a, b)]
```

**거리 구하기**

```
        루트(0)
         ↓
        LCA 
      ↙   ↘
    ...   ...
    ↓       ↓
    A       B
```

- `dist[a] = dist[LCA] + dist(LCA → A)`

- `dist[b] = dist[LCA] + dist(LCA → B)`

- `dist[a] + dist[b] = 2 * dist[LCA] + dist(LCA → A) + dist(LCA → B)`

> A와 B의 거리는
- `dist(LCA → A) + dist(LCA → B) (a와 b사이의 거리) = dist[a] + dist[b] - (2 * dist[LCA])`


**점화식**
```cs
// DFS/BFS로 거리 계산
dist[child] = dist[node] + cost;

// 쿼리 처리
int lca = LCA(a, b);
int distance = dist[a] + dist[b] - 2 * dist[lca];
```

**핵심 규칙**

> 루트부터 각 노드까지의 거리를 저장해두면, LCA를 이용해 두 노드 사이의 거리를 O(log N)에 계산할 수 있다.

---

## 마무리

- 희소 배열은 **"2진법 분해"** 라는 단순한 아이디어로 지수적 가속을 만든다.
- LCA는 **"다르면 올라감"** 규칙만 이해하면 구현이 명확해진다.
- 19번 이동 = 16 + 2 + 1 = **3번 연산**. 이것이 희소 배열의 아름다움이다!
- 비트 연산, 반복문 범위, 스택 오버플로우만 조심하면 대부분의 버그는 막을 수 있다.
