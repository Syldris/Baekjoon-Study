## ✅ 단조 덱 (Monotonic Deque)

### 💡 핵심 개념

덱(Deque) 내부 원소의 값이 단조롭게 정렬되도록 유지하면서,  
슬라이딩 윈도우 범위 안의 **최댓값(또는 최솟값)** 을 빠르게 구하는 자료구조이다.

> 📌 주로 **"슬라이딩 윈도우 안의 최대/최소"** 문제에서  
> **시간복잡도 `O(N)`** 으로 문제를 해결할 수 있는 테크닉

---

### ⏱️ 시간복잡도

| 방식          | 시간복잡도   | 비고                           |
|---------------|--------------|--------------------------------|
| 완전탐색      | O(NM)        | 구간마다 `max()` 순회         |
| 우선순위 큐   | O(N log M)   | 시간 상수가 크게붙어 세그트리 보다 오래걸림         |
| **단조 덱**   | **O(N)**     | 최적, 인덱스당 최대 1번 삽입/삭제 |
| 세그트리      | O(N log N)   | 우선순위 큐보다 빠르지만 구현 복잡함 |

---

### 🧠 아이디어 요약

- 덱에는 **현재까지 확인한 인덱스**를 저장한다.
- 덱은 항상 **내림차순(또는 오름차순)** 형태로 유지한다.
- 새로운 값이 들어오면, **덱의 뒤쪽 값이 현재보다 작으면 제거**한다.  
  → 현재 값이 더 강력하므로 그 전에 본 값은 쓸모없음!
- 덱의 앞쪽 값이 **슬라이딩 윈도우 범위를 벗어나면 제거**한다.
- 덱의 `First`가 항상 현재 구간의 **최댓값을 가지는 인덱스**가 된다.

---

### 📦 단조 덱 동작 방식 (최댓값 기준)

| 연산 | 설명 |
|------|------|
| `while (arr[deque.Last.Value] <= arr[i])` | 현재 값보다 작거나 같은 값은 뒤에서 제거 |
| `deque.AddLast(i)` | 현재 인덱스 삽입 |
| `if (deque.First.Value <= i - window)` | 윈도우 범위를 벗어난 인덱스는 앞에서 제거 |
| `arr[deque.First.Value]` | 현재 구간의 최댓값 |

> 💡 내림차순 덱을 유지하면, 가장 앞에 항상 **최댓값** 이 위치함

---

### 🧩 구현 시 주의할 점

- **덱 갱신 순서 중요**:  
  삽입 → 정답 추가 → 범위 초과 제거  
  → 현재 값을 포함한 범위에서 정확한 결과 도출 가능

- **범위 계산 주의**:  
  - 슬라이딩 윈도우 범위를 잘 체크해서 계산해야한다.
  - 예시로 슬라이딩 윈도우 크기가 `2m - 1`이라면,  
  - `i >= 2 * m - 2`에서 정답을 추가하고  
  - `deque.First.Value < i - (2m - 2)`이면 제거한다

---
### 🔍관련문제 
## [백준 1306번: 달려라 홍준](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/1306.%E2%80%85%EB%8B%AC%EB%A0%A4%EB%9D%BC%E2%80%85%ED%99%8D%EC%A4%80)
## [백준 11003번: 최솟값 찾기](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/11003.%E2%80%85%EC%B5%9C%EC%86%9F%EA%B0%92%E2%80%85%EC%B0%BE%EA%B8%B0)

### 🔍 예시

```text
입력:
5 2
1 2 3 4 5

윈도우 크기 = 3  
윈도우 범위: [0~2], [1~3], [2~4]

출력:
3 4 5
```
### ✅ 느낀 점
- 슬라이딩 윈도우 + 범위내 값 찾기 유형에서 빠른 O(N) 풀이가 가능하다!

- 정확한 범위 계산과 동작 순서의 이해가 핵심이다!

- 처음에는 헷갈리지만, 익숙해지면 구간내 값이 바뀌지않는 문제에서 효율적으로 사용할수 있다!
