## [백준 14003번: 가장 긴 증가하는 부분 수열 5](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/14003.%E2%80%85%EA%B0%80%EC%9E%A5%E2%80%85%EA%B8%B4%E2%80%85%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94%E2%80%85%EB%B6%80%EB%B6%84%E2%80%85%EC%88%98%EC%97%B4%E2%80%855)


### ✅ 문제 요약
- **가장 긴 증가하는 부분 수열 5 (LIS 5)**
- 수열이 주어졌을 때, 가장 긴 증가하는 부분 수열의 길이와 실제 수열을 출력하는 문제
- 수열 길이 N은 최대 **1,000,000 → O(N log N)** 알고리즘 필요
> 이 문제는 최장 증가 부분 수열의 수열까지 출력해야 하므로
> 
> 단순히 길이만 구하는 **O(N log N) LIS 코드**에 **역추적** 로직을 추가해야 한다.
---

### 💡 핵심 개념
1. **이분 탐색을 활용한 LIS 길이 구하기 (O(N log N))**
2. **역추적을 위한 `prev`, `listIndex` 배열 사용**

---

### 🔍 로직 설명

- `list`: 현재까지 LIS를 만들기 위한 **최소값들**을 저장 (실제 수열과는 다름)
- `listIndex`: `list`의 각 원소가 원래 배열 `arr`에서 **어떤 인덱스**였는지 저장
- `prev[i]`: `arr[i]` 앞에 오는 LIS 구성 요소의 **인덱스**를 저장 (역추적용)

---

### 🧠 동작 예시

#### 입력 수열:  
`arr = [10, 20, 5, 30, 20, 50]`

| i | num | list 변경         | listIndex    | prev 갱신     |
|---|-----|--------------------|--------------|---------------|
| 0 | 10  | [10]               | [0]          | prev[0] = -1  |
| 1 | 20  | [10, 20]           | [0, 1]       | prev[1] = 0   |
| 2 | 5   | [5, 20]            | [2, 1]       | prev[2] = -1  |
| 3 | 30  | [5, 20, 30]        | [2, 1, 3]    | prev[3] = 1   |
| 4 | 20  | [5, 20, 30] (갱신) | [2, 4, 3]    | prev[4] = 2   |
| 5 | 50  | [5, 20, 30, 50]    | [2, 4, 3, 5] | prev[5] = 3   |

---

### 🔁 역추적 과정

- `listIndex`의 마지막 값 → 5 (arr[5] = 50)  
  → `prev[5] = 3` (arr[3] = 30)  
  → `prev[3] = 1` (arr[1] = 20)  
  → `prev[1] = 0` (arr[0] = 10)  
  → `prev[0] = -1` → 종료

🔹 **최종 수열 =** `10 → 20 → 30 → 50`  
🔹 **길이 =** `4`

---

### ✅ 최종 출력 예시

- 입력
- `6`
- **`10 20 5 30 20 50`**
- 출력
- `4`
- **`10 20 30 50`**

---

### 💬 참고

- `list`는 **LIS 값 자체가 아니라**, 길이를 구하기 위한 **보조 리스트**
- 실제 수열은 `prev` + `listIndex`를 통해 **역추적**으로 완성함
- **경로 저장**이 핵심이기 때문에 `prev` 배열이 꼭 필요함
