## 📝 오답노트 5719 - 거의 최단 경로
### [문제 해설은 이쪽으로](https://github.com/Syldris/Baekjoon-Study/blob/main/%EC%A4%91%EC%9A%94%ED%95%9C%20%EB%AC%B8%EC%A0%9C%EB%AA%A8%EC%9D%8C/%5B%EA%B7%B8%EB%9E%98%ED%94%84%5D%5B%EA%B3%A0%EB%82%9C%EC%9D%B4%EB%8F%84%5D%20%EA%B1%B0%EC%9D%98%20%EC%B5%9C%EB%8B%A8%20%EA%B2%BD%EB%A1%9C.md)
---

#### ❌ 실수/오답 포인트

- **최단 경로가 여러 개일 수 있다는 점은 알았지만, 역추적을 한 경로만 해서 틀림**
  - `prev[]` 배열은 **단 하나의 최단경로**만 저장할 수 있음  
  → **모든 최단 경로 간선**을 저장해야 했음
  - 따라서 **인접리스트 형식**으로 구현하여 **모든 최단 경로 간선**을 구함

- **"거의 최단 경로와 최단경로 둘다" 없을 경우 `-1` 출력이 두 번 나오는 문제**
  - 다익스트라 2회 모두 실패 시 `-1`을 두 번 출력  
  → 출력 로직을 정리해서 **딱 한 번만** 출력하도록 수정함

- **경로 역추적을 재귀(백트래킹)로 처리해서 시간초과**
  - 한 노드에서 분기 많아질 경우 **n² 이상 시간복잡도**  
  → `Queue`를 이용한 **BFS 역추적**으로 최적화
  → 방문처리 실수로 인한 **메모리 초과**로 **방문배열**을 만들어 큐에 다시 삽입되지 않게 최적화

- **간선을 제거하는 방식에서 또 시간초과**
  - 리스트 기반 그래프에서 제거하면 탐색 비용 높음  
  → `removed[from, to] = true`로 **"삭제가 아닌 무시"** 방식 도입

---

#### ✅ 교훈

- **"모든 최단 경로"를 저장하고 추적해야 할 경우**, 일반 배열 대신 **인접리스트**을 사용하자.
- **간선 제거는 직접 제거보다 "무시하는 방식"이 더 빠를 수 있다.**
- **출력은 문제 조건을 정확히 읽고, 한 번만 하도록 신경쓰자.**
- **재귀보다 BFS로 구현하면 시간복잡도에서 훨씬 유리한 경우가 있다.**
---
⏱ **총 소요 시간: 5시간 30분**

❌**틀린횟수 21회**
![image](https://github.com/user-attachments/assets/5168ffe4-57dd-410e-ace7-09a8782f7ff1)

#### 후기
- 놀랍게도 혼자서 1페이지를 채우고 다음페이지까지 생겨버렸다..
- 문제가 언뜻보기에 쉬워 첫 플레티넘 문제로 도전했지만 정답률 19%의 벽은 높았다..!
