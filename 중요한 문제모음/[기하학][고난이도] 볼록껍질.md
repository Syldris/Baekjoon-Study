## [ë°±ì¤€ 1708ë²ˆ: ë³¼ë¡ê»ì§ˆ](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/1708.%E2%80%85%EB%B3%BC%EB%A1%9D%E2%80%85%EA%BB%8D%EC%A7%88)

### âœ… ë¬¸ì œ ìš”ì•½

2ì°¨ì› í‰ë©´ì— Nê°œì˜ ì ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ì ë“¤ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ” ê°€ì¥ ì‘ì€ ë³¼ë¡ ë‹¤ê°í˜•(Convex Hull)ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤.  
ì¦‰, **ë³¼ë¡ê»ì§ˆ**ì„ êµ¬í•˜ê³ , ê·¸ ê»ì§ˆì„ ì´ë£¨ëŠ” ì ì˜ **ê°œìˆ˜**ë¥¼ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ.

---

### ğŸ’¡ í•µì‹¬ ê°œë… 

1. **ë³¼ë¡ê»ì§ˆ (Convex Hull)**  
   - í‰ë©´ìƒì˜ ì ë“¤ ì¤‘ ê°€ì¥ ë°”ê¹¥ì„ ë‘˜ëŸ¬ì‹¸ëŠ” ì„ ë¶„ë“¤ë¡œ ì´ë£¨ì–´ì§„ ë‹¤ê°í˜•.
   - ëŒ€í‘œ ì•Œê³ ë¦¬ì¦˜: **Graham Scan**, **Andrewâ€™s Monotone Chain**

2. **ì™¸ì  (Cross Product)**  
   - ì„¸ ì  A, B, Cê°€ **ë°˜ì‹œê³„ ë°©í–¥**ì¼ ì¡°ê±´:  
     `Cross(B - A, C - B) > 0`  
   - ê³µì‹ì„ ê¸°ì–µí•˜ê¸°:  
     `a.x * b.y - a.y * b.x`
    â†’ ë‘ ë²¡í„°ì˜ ì™¸ì  ê°’ìœ¼ë¡œ, ë°©í–¥(ë°˜ì‹œê³„/ì‹œê³„)ì„ íŒë³„í•˜ëŠ” ë° ì‚¬ìš©ë¨.

    - A(xâ‚, yâ‚)  
    - B(xâ‚‚, yâ‚‚)  
    - C(xâ‚ƒ, yâ‚ƒ)  

    - ë²¡í„° AB = (xâ‚‚ - xâ‚, yâ‚‚ - yâ‚)  
    - ë²¡í„° BC = (xâ‚ƒ - xâ‚‚, yâ‚ƒ - yâ‚‚)  

    - ì™¸ì (Cross) = (AB.x * BC.y) - (AB.y * BC.x)  

    ```
          C
         /
        /
   B ---
      \
       \
        A
    ```

    - ì™¸ì  > 0  : ë°˜ì‹œê³„ ë°©í–¥ (ì™¼ìª½ìœ¼ë¡œ ë„ëŠ” ë°©í–¥)  
    - ì™¸ì  < 0  : ì‹œê³„ ë°©í–¥ (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë„ëŠ” ë°©í–¥)  
    - ì™¸ì  = 0  : ì„¸ ì ì´ í•œ ì§ì„ ìƒ (í‰í–‰ or ì¼ì§ì„ )  


 
---

### ğŸ§  ì‚¬ìš©í•œ ë¡œì§

- **ê¸°ì¤€ì (ìµœí•˜ë‹¨ ì¢Œí‘œ, xê°€ ë” ì‘ì€ ìˆœ)** ì„ ë¨¼ì € ì°¾ì•„ ë°°ì—´ ë§¨ ì•ìœ¼ë¡œ ì˜®ê¹€
- ê¸°ì¤€ì ìœ¼ë¡œë¶€í„°ì˜ **ê°ë„ ì •ë ¬**ì„ ìˆ˜í–‰í•¨  
  â†’ ì‹¤ì œ êµ¬í˜„ì€ ì™¸ì  ë¹„êµë¡œ ì •ë ¬
- ì •ë ¬ëœ ìˆœì„œë¡œ ì ë“¤ì„ ìŠ¤íƒì— ìŒ“ì•„ê°€ë©´ì„œ  
  â†’ ì™¸ì  ê²°ê³¼ê°€ **ì‹œê³„ë°©í–¥(<= 0)** ì´ë©´ popí•´ì„œ ë˜ëŒì•„ê°
  â†’ **ë°˜ì‹œê³„ ë°©í–¥ì¼ ë•Œë§Œ push**

---

### ğŸ§ª ì‹¤ìˆ˜í–ˆë˜ ë¶€ë¶„

- **ì™¸ì  êµ¬í˜„ ì‹¤ìˆ˜**: `a.x * b.y - a.y * b.x` ê¼­ ê¸°ì–µ!
- ì •ë ¬í•  ë•Œ, **ê°™ì€ ê°ë„ë¼ë©´ ê±°ë¦¬ ì§§ì€ ì ì´ ë¨¼ì € ì™€ì•¼ í•¨**
- â†’ ì™¸ì  ê²°ê³¼ê°€ **0ì´ë¼ë©´** ê°™ì€ ë°©í–¥ì´ë¯€ë¡œ, ì •ë ¬ ì‹œ ê±°ë¦¬ ì§§ì€ ì ì´ ë¨¼ì € ì˜¤ê³ , ì´í›„ ìŠ¤íƒì—ì„œ ì¤‘ê°„ ì ì€ popë˜ì–´ ì œê±°ëœë‹¤"
---

### âœ… [ìµœì¢… ì½”ë“œ(C#)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Platinum/1708.%E2%80%85%EB%B3%BC%EB%A1%9D%E2%80%85%EA%BB%8D%EC%A7%88)
<details>
<summary><b>C# ë³¼ë¡ê»ì§ˆ ì½”ë“œ(ì£¼ì„í¬í•¨) ëˆŒëŸ¬ì„œ í¼ì³ë³´ê¸°</b></summary>
  
```csharp
#nullable disable
using System;
class Program
{
    public struct Point
    {
        public long x;
        public long y;
        public Point(long x, long y)
        {
            this.x = x;
            this.y = y;
        }
    }

    static void Main()
    {
        using StreamReader sr = new StreamReader(new BufferedStream(Console.OpenStandardInput()));
        using StreamWriter sw = new StreamWriter(new BufferedStream(Console.OpenStandardOutput()));

        int n = int.Parse(sr.ReadLine());
        Point[] points = new Point[n];

        // ì…ë ¥ë°›ì€ ì ë“¤ì„ ë°°ì—´ì— ì €ì¥
        for (int i = 0; i < n; i++)
        {
            string[] input = sr.ReadLine().Split();
            int x = int.Parse(input[0]);
            int y = int.Parse(input[1]);
            points[i] = new Point(x, y);
        }

        // ê¸°ì¤€ì (pivot): yê°€ ê°€ì¥ ì‘ê³ , ê°™ìœ¼ë©´ xê°€ ê°€ì¥ ì‘ì€ ì  ì°¾ê¸°
        int pivot = 0;
        for (int i = 1; i < n; i++)
        {
            if (points[i].y < points[pivot].y || points[i].y == points[pivot].y && points[i].x < points[pivot].x)
            {
                pivot = i;
            }
        }

        // ê¸°ì¤€ì ì„ ë°°ì—´ ë§¨ ì•ìœ¼ë¡œ êµí™˜
        (points[0], points[pivot]) = (points[pivot], points[0]);

        // ë‘ ì ì˜ ë²¡í„° ì°¨ì´ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜ (a - b)
        Point Sub(Point a, Point b) => new Point(a.x - b.x, a.y - b.y);

        // ë‘ ë²¡í„°ì˜ ì™¸ì  ê³„ì‚° (a Ã— b)
        long Cross(Point a, Point b) => a.x * b.y - a.y * b.x;

        // ê¸°ì¤€ì  ê¸°ì¤€ìœ¼ë¡œ ë°˜ì‹œê³„ ë°©í–¥(ì™¸ì  ê¸°ì¤€)ê³¼ ê±°ë¦¬ ìˆœì„œëŒ€ë¡œ ì •ë ¬
        Array.Sort(points, 1, n - 1, Comparer<Point>.Create((a, b) =>
        {
            Point va = Sub(a, points[0]); // ê¸°ì¤€ì ì—ì„œ aë¡œ ê°€ëŠ” ë²¡í„°
            Point vb = Sub(b, points[0]); // ê¸°ì¤€ì ì—ì„œ bë¡œ ê°€ëŠ” ë²¡í„°
            long cross = Cross(va, vb);   // ì™¸ì  ê²°ê³¼ë¡œ ê°ë„ ë¹„êµ

            if (cross != 0) return cross > 0 ? -1 : 1; // ë°˜ì‹œê³„ ë°©í–¥ì´ë©´ aê°€ bë³´ë‹¤ ì•

            // ì™¸ì ì´ 0ì´ë©´ ê°™ì€ ë°©í–¥ â†’ ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ì ì´ ë¨¼ì € ì˜¤ë„ë¡ ì •ë ¬
            long distA = va.x * va.x + va.y * va.y;
            long distB = vb.x * vb.x + vb.y * vb.y;

            return distA.CompareTo(distB); //ê°’ë¹„êµë¡œ ìˆœì„œ ì •ë ¬
        }));

        Stack<Point> stack = new Stack<Point>();
        // ìŠ¤íƒì— ê¸°ì¤€ì ê³¼ ê·¸ ë‹¤ìŒ ì  ë„£ê¸°
        stack.Push(points[0]);
        stack.Push(points[1]);

        // ì •ë ¬ëœ ì ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ë©° ë³¼ë¡ê»ì§ˆ êµ¬ì„±
        for (int i = 2; i < n; i++)
        {
            // ìŠ¤íƒ ê¼­ëŒ€ê¸° ë‘ ì ê³¼ í˜„ì¬ ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë°©í–¥ì´ ë°˜ì‹œê³„ ë°©í–¥ì¸ì§€ ê²€ì‚¬
            while (stack.Count >= 2)
            {
                Point top = stack.Pop();   // ìŠ¤íƒì—ì„œ ê°€ì¥ ìœ„ ì  êº¼ë‚´ê¸°
                Point peek = stack.Peek(); // êº¼ë‚¸ ì  ì•„ë˜ ì  í™•ì¸

                Point dist1 = Sub(top, peek);      // peek -> top ë²¡í„°
                Point dist2 = Sub(points[i], top); // top -> í˜„ì¬ ì  ë²¡í„°

                long cross = Cross(dist1, dist2);

                if (cross > 0) // ë°˜ì‹œê³„ ë°©í–¥ì´ë©´ top ë‹¤ì‹œ ë„£ê³  while íƒˆì¶œ
                {
                    stack.Push(top);
                    break;
                }
                // ì‹œê³„ ë°©í–¥ì´ë©´ top ë²„ë¦¬ê³  ë‹¤ì‹œ ê²€ì‚¬
            }
            stack.Push(points[i]); // í˜„ì¬ ì ì„ ìŠ¤íƒì— ì¶”ê°€
        }
        // ìŠ¤íƒì— ë‚¨ì•„ìˆëŠ” ì  ê°œìˆ˜ê°€ ë³¼ë¡ê»ì§ˆì„ ì´ë£¨ëŠ” ì  ê°œìˆ˜
        sw.Write(stack.Count);
    }
}

```

</details>
