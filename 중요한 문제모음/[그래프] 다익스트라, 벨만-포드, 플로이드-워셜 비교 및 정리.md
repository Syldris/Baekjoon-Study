#  최단거리 알고리즘 비교: 다익스트라 vs 벨만-포드 vs 플로이드-워셜
---
## [다익스트라(Dijkstra, 최단경로)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/1753.%E2%80%85%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C) 
## [벨만-포드(Bellman-Ford, 타임머신)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11657.%E2%80%85%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0)
## [플로이드-워셜(Floyd-Warshall, 플로이드)](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11404.%E2%80%85%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)

### ✅ 문제 요약

| 알고리즘     | 대표 문제                              | 특징                           |
|--------------|-------------------------------------|--------------------------------|
| 다익스트라   | [최단경로](https://www.acmicpc.net/problem/1753) | 양의 간선만 있을 때 최단거리      |
| 벨만-포드   | [타임머신](https://www.acmicpc.net/problem/11657) | 음수 간선 + 음수 사이클 판별 가능 |
| 플로이드-워셜 | [플로이드](https://www.acmicpc.net/problem/11404) | 모든 정점 쌍 최단거리, 음수 간선 가능 |

---

### 🧠 핵심 개념 비교

| 항목            | 다익스트라                 | 벨만-포드                    | 플로이드-워셜                      |
|-----------------|----------------------------|------------------------------|-----------------------------------|
| **음수 간선**     | ❌ 불가능                  | ✅ 가능                      | ✅ 가능                           |
| **음수 사이클 판별** | ❌ 불가능                  | ✅ 가능                      | ✅ 가능 (대각선 값 음수 확인)      |
| **시간복잡도**    | `O(E log V)` (우선순위 큐 사용 시) | `O(V * E)`                  | `O(V^3)`                        |
| **탐색 기준**    | 정점 기준 (우선순위 큐)     | 간선 기준 (Relaxation)       | 정점 3중 반복 (경유지 기준)         |
| **사용 자료구조** | `List[] + PriorityQueue` **인접리스트**    | `List<(from,to,cost)>` **간선저장**       | `int[,] dist` **인접행렬**    |
| **사용 상황**    | 양수 가중치 최단경로 문제    | 음수 간선 및 음수 사이클 판별 | 모든 정점 쌍 최단거리 필요 시       |

---

### 🧩 알고리즘 선택 기준

| 상황                       | 추천 알고리즘       |
|---------------------------|---------------------|
| 양의 가중치만 있을 때       | ✅ 다익스트라        |
| 음수 가중치가 있을 때       | ✅ 벨만-포드         |
| 모든 정점 쌍 최단거리 필요할 때 | ✅ 플로이드-워셜      |

---
### 💡 알고리즘 실전 코드

#### [다익스트라 전체코드](https://github.com/Syldris/Baekjoon-Study/blob/main/C%23/%EB%B0%B1%EC%A4%80/Gold/1753.%E2%80%85%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C.cs)
<details>
<summary>C# 다익스트라 의사 코드 펼쳐보기</summary> 
  
```csharp
PriorityQueue<(int node, int cost), int> pq = new();
pq.Enqueue((start, 0), 0);
while (pq.Count > 0)
{
    var (cur, curCost) = pq.Dequeue();
    foreach (var (next, cost) in graph[cur])
    {
        if (dist[next] > dist[cur] + cost)
        {
            dist[next] = dist[cur] + cost;
            pq.Enqueue((next, dist[next]), dist[next]);
        }
    }
}
```
  
</details>


#### [벨만-포드 전체코드](https://github.com/Syldris/Baekjoon-Study/blob/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11657.%E2%80%85%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0/%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0.cs)
<details>
<summary>C# 벨만-포드 의사 코드 펼쳐보기</summary> 
  
```csharp
List<(int from, int to, int cost)> edges = new();

for (int i = 1; i <= n; i++)
{
    foreach (var (from, to, cost) in edges)
    {
        if (dist[from] != INF && dist[from] + cost < dist[to])
        {
            dist[to] = dist[from] + cost;
        }
    }
}

// 음수 사이클 판별
foreach (var (from, to, cost) in edges)
{
    if (dist[from] != INF && dist[from] + cost < dist[to])
    {
        Console.WriteLine("-1"); // 음수 사이클 존재
        return;
    }
}
```
</details>

#### [플로이드-워셜 전체코드](https://github.com/Syldris/Baekjoon-Study/blob/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11404.%E2%80%85%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C.cs)
<details>
<summary>C# 플로이드-워셜 의사 코드 펼쳐보기</summary>
  
```csharp
int[,] dist = new int[n + 1, n + 1];

// 초기화
for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= n; j++)
    {
        if (i == j) dist[i, j] = 0;
        else dist[i, j] = INF;
    }
}

foreach (var (from, to, cost) in edges)
{
    dist[from, to] = cost;
}

for (int k = 1; k <= n; k++)
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (dist[i, k] != INF && dist[k, j] != INF)
            {
                dist[i, j] = Math.Min(dist[i, j], dist[i, k] + dist[k, j]);
            }
        }
    }
}
```
</details>
