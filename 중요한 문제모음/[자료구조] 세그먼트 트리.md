# ✅ 세그먼트 트리 

## 💡 세그트리 개념

- **구간 합, 최솟값, 최댓값 등 구간 쿼리를 O(log N) 시간에 처리하기 위한 트리 구조**
- **완전 이진 트리 형태**  
  N개의 원소를 담으려면 리프 노드 개수가 N 이상인 2의 거듭제곱이어야 함  
  → 리프 노드 수: `2^ceil(log2 N)`

- 트리 전체 노드 수는 최대 `2 * 2^ceil(log₂N) - 1`
- 배열 크기는 안전하게 `4 * N` 정도를 잡으면 된다 (모든상황에서 4N을 넘지 않음)

---
### ⏱️ 일반 배열 / 누적합 / 세그트리 시간 복잡도 비교

| 자료구조         | 업데이트 시간복잡도           | 구간 질의 시간복잡도 |
|------------------|------------------------------|----------------------|
| 일반 배열         |**O(1)**                          | O(N)                 |
| 누적합 배열       | O(N)                      | **O(1)**                 |
| 세그먼트 트리     | **O(log₂N)**                      | **O(log₂N)**             |
> **구간 질의: 특정 범위([L, R])에 대한 합, 최솟값 등을 구하는 연산**
---

## 💡 오늘 고민한 주요 내용

- **세그먼트 트리를 왜 쓰는지?**

- 일반 배열, 누적합 배열로는 **업데이트와 구간 질의를 모두 빠르게 처리할 수 없음**
- 세그먼트 트리는 **O(log₂N)** 시간에 구간 합, 최소/최대, 구간 gcd 등 다양한 구간 연산을 지원  
- 특히 **데이터가 변경되면서 구간 질의를 여러 번 수행해야 할 때 최적**
- ex) 동적 구간 합, 최솟값 갱신 + 질의 문제, 여러 번의 쿼리와 업데이트가 섞인 문제

 
- **왜 배열 크기를 4N으로 잡나?**  
  → 세그트리는 완전 이진 트리라서 위로 갈수록 절반씩 줄어들어 전체 노드 수는 4N을 넘지 않음  
  → `4N` > `2 * 2^ceil(log₂N) - 1` 이므로 4N으로 크기를 잡아 여유있게 배열크기를 유지

- **리프 노드는 원본 데이터와 매핑됨**
- **구간이 클수록 부모 노드는 더 큰 범위를 담고 있음**

---

## 💡 세그먼트트리 배열 인덱스와 구조 이해

- 리프 노드가 N개 이상 되도록 **2의 거듭제곱**으로 맞춤  
- 리프 노드 + 내부 노드 포함 최대 `4N` 크기의 배열이면 충분  
- 배열의 각 인덱스는 구간 `[L, R]` 의 값을 관리  
- **구간을 나누는 방식 때문에 일부 배열 인덱스는 공간이 비는 것처럼 보일 수 있음**  
- 자식 노드는 **왼쪽: 2 * n, 오른쪽: 2 * n + 1** 인덱스를 가짐  
- 부모는 자식을 병합하여 값을 계산 (예: 합, 최솟값, 최댓값)


---

## 💡 앞으로 공부할 내용

- ~~직접 구현해보며 빌드 / 업데이트 / 쿼리 과정을 손에 익히기~~ **(달성)**
- 세그먼트 트리를 직접 사용하여 문제들을 풀며 세그먼트에 익숙해졌다!
- 세그먼트트리 직접 사용해본 문제(코드 포함)
> [구간 합 구하기](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/2042.%E2%80%85%EA%B5%AC%EA%B0%84%E2%80%85%ED%95%A9%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0)
>
> [구간 곱 구하기](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/11505.%E2%80%85%EA%B5%AC%EA%B0%84%E2%80%85%EA%B3%B1%E2%80%85%EA%B5%AC%ED%95%98%EA%B8%B0)
>
> [수열과 쿼리 16](https://github.com/Syldris/Baekjoon-Study/tree/main/C%23/%EB%B0%B1%EC%A4%80/Gold/14428.%E2%80%85%EC%88%98%EC%97%B4%EA%B3%BC%E2%80%85%EC%BF%BC%EB%A6%AC%E2%80%8516) **(고난이도)**
- 느리게 갱신되는 세그먼트트리 (Lazy Propagation)도 다음에 도전

---
### 💡 사용하면서 추가로 이해한점
- 세그먼트 트리는 **빌드, 업데이트, 쿼리** 3단계 과정으로 **동작(아래 서술함)**  
- `node = 1`에서 시작하며 이 노드는 전체 구간을 담음  
- 내려갈수록 **좁은 범위** → 리프 노드는 **자기 자신만 포함**  
- 세그먼트 트리의 핵심은 **이분탐색 + 재귀적 탐색 + 부모가 자식을 병합하여 저장함**
- 
## 💡 세그먼트 트리 3가지 과정

### 🌱 Build(int 반환)
- `node`, `start`, `end`를 매개변수로 이분탐색 + 재귀로 트리 생성
- 리프 노드에 도달하면 자기 값을 저장  
- 부모 노드는 **자식 노드 값들을 병합**해 저장  

### ✏️ Update(반환 없음)
- `node`, `start`, `end`, `index`, `value`로 갱신 수행  
- **index가 범위를 벗어나면 무시**  
  → `index < start || end < index`
- **리프 노드라면 값 업데이트**  
  → `start == end` 이면 index의 리프노드 이므로 업데이트  
- **부분 구간이면 이분탐색으로 내려가면서 갱신**  
  → mid 기준 왼쪽/오른쪽 자식 갱신  
- 부모 노드 값은 갱신된 자식 값으로 다시 병합  

### 🔍 Query(int 반환)
- `node`, `start`, `end`, `left`, `right`로 질의 처리  
- **구간 밖이면 무시 (영향 없음)**  
  → `end < left || start > right`
- **구간 안에 완전히 포함되면 현재 노드 값 리턴**  
  → `left <= start && end <= right`
- **일부만 겹치면 이분탐색으로 자식 노드 탐색**
  → 왼쪽/오른쪽 값 병합해 반환  

--- 

## ✨ 느낀 점

- 세그트리 구조가 처음엔 헷갈렸지만, 완전 이진 트리 개념과 함께 자료구조 지식이 있어 이해하는데 도움이 됐다!
- 배열 인덱스 만으로도 세그먼트 트리를 완전히 나타낼수 있는게 신기하였다.
> **루트 = 1번 인덱스**
>
> **왼쪽 자식 = 2 * 부모 인덱스**, **오른쪽 자식 = 2 * 부모 인덱스 + 1**

> **N=6 일때 구조(인덱스)**
```
                  [1,6](1) 
               /           \
        [1,3](2)             [4,6](3)
       /     \              /     \
   [1,2](4)  [3,3](5)   [4,5](6)   [6,6](7)
   /    \               /     \
[1,1](8) [2,2](9)    [4,4](12) [5,5](13)

```
